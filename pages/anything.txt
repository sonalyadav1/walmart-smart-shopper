'use client';

import {
  MapContainer,
  Rectangle,
  Polyline,
  Marker,
  Tooltip,
  Polygon,
  useMap
} from 'react-leaflet';
import { useEffect, useState, useMemo, useRef } from 'react';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';

// Custom component to handle view changes
function SetViewOnClick({ coords, zoom }) {
  const map = useMap();
  
  useEffect(() => {
    if (coords) {
      map.flyTo(coords, zoom, {
        duration: 1,
        easeLinearity: 0.25
      });
    }
  }, [coords, zoom, map]);

  return null;
}

const startPoint = [3, 3];

const IndoorMapComponent = () => {
  // State and refs
  const [mapData, setMapData] = useState(null);
  const [productList, setProductList] = useState([]);
  const [path, setPath] = useState([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const mapRef = useRef(null);
  const [mapReady, setMapReady] = useState(false);
  const [currentCoords, setCurrentCoords] = useState(null);
  const [currentZoom, setCurrentZoom] = useState(3);

  // Fetch map data
  useEffect(() => {
    const fetchMapData = async () => {
      try {
        setIsLoading(true);
        const response = await fetch('http://localhost:5000/api/map');
        const data = await response.json();
        setMapData(data);
        
        const detailed = JSON.parse(localStorage.getItem('pathProductsDetails')) || [];
        const validProducts = detailed.flat().filter(p => p && p.name && p.category);
        setProductList(validProducts);
      } catch (err) {
        console.error('‚ùå Map fetch failed:', err);
        setError('Failed to load store map data. Please try again later.');
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchMapData();
  }, []);

  // Process selected categories
  const selectedCategories = useMemo(() => {
    if (!mapData || !mapData.categories || !Array.isArray(mapData.categories)) return [];
    
    return mapData.categories.filter(cat => 
      productList.some(prod => prod.category === cat.name)
    );
  }, [mapData, productList]);

  // Create optimized path
  const optimizedPath = useMemo(() => {
    if (!mapData || !mapData.grid || selectedCategories.length === 0) return [];
    
    // Simplified path algorithm
    const points = [startPoint, ...selectedCategories.map(cat => 
      [Math.floor(cat.position[0] + cat.size[0]/2), 
       Math.floor(cat.position[1] + cat.size[1]/2)]
    )];
    
    return points.map(([x, y]) => [y + 0.5, x + 0.5]);
  }, [mapData, selectedCategories]);

  // Update path when optimizedPath changes
  useEffect(() => {
    if (optimizedPath.length > 0) {
      setPath(optimizedPath);
      setCurrentIndex(0);
      
      // Auto-fly to first point when map is ready
      if (mapReady && mapRef.current) {
        setTimeout(() => {
          setCurrentCoords(optimizedPath[0]);
          setCurrentZoom(5);
        }, 300);
      }
    }
  }, [optimizedPath, mapReady]);

  // Fly to current point when index changes
  useEffect(() => {
    if (path.length > 0 && currentIndex < path.length) {
      setCurrentCoords(path[currentIndex]);
      setCurrentZoom(3); // Zoom in when navigating to a point
    }
  }, [currentIndex, path]);

  // Navigation handlers
  const handleNextPoint = () => {
    if (currentIndex >= path.length - 1) return;
    setCurrentIndex(prev => Math.min(prev + 1, path.length - 1));
  };

  const handlePrevPoint = () => {
    if (currentIndex <= 0) return;
    setCurrentIndex(prev => Math.max(prev - 1, 0));
  };

  // Render grid efficiently
  const renderGrid = () => {
    if (!mapData || !mapData.grid) return null;
    
    return mapData.grid.map((row, y) => 
      row.map((cell, x) => {
        if (cell === 1) { // Shelf
          return (
            <Rectangle
              key={`shelf-${x}-${y}`}
              bounds={[[y, x], [y+1, x+1]]}
              pathOptions={{ 
                fillColor: '#a1887f', 
                color: '#5d4037', 
                fillOpacity: 0.7 
              }}
            />
          );
        } else if (cell === 9) { // Wall/Border
          return (
            <Rectangle
              key={`wall-${x}-${y}`}
              bounds={[[y, x], [y+1, x+1]]}
              pathOptions={{ 
                fillColor: '#333', 
                color: '#000', 
                fillOpacity: 1 
              }}
            />
          );
        }
        return null;
      })
    );
  };

  // Loading and error states
  if (isLoading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <p>Loading store map...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="error-container">
        <div className="error-icon">‚ùå</div>
        <p>{error}</p>
        <button className="retry-btn" onClick={() => window.location.reload()}>
          Try Again
        </button>
      </div>
    );
  }

  // Get dimensions safely
  const width = mapData?.dimensions?.width || (mapData?.grid?.[0]?.length || 100);
  const height = mapData?.dimensions?.height || (mapData?.grid?.length || 100);

  return (
    <div className="map-dashboard">
      <div className="map-controls">
        <h2 className="map-title">Store Navigation</h2>
        <div className="navigation-controls">
          <button 
            className="nav-btn prev-btn" 
            onClick={handlePrevPoint}
            disabled={currentIndex <= 0}
          >
            ‚óÄ Previous
          </button>
          <div className="path-progress">
            Step {currentIndex + 1} of {path.length}
          </div>
          <button 
            className="nav-btn next-btn" 
            onClick={handleNextPoint}
            disabled={currentIndex >= path.length - 1}
          >
            Next ‚ñ∂
          </button>
        </div>
      </div>
      
      <div className="map-wrapper">
        <MapContainer
          center={[height / 2, width / 2]}
          zoom={2}
          crs={L.CRS.Simple}
          minZoom={1}
          maxZoom={5}
          maxBounds={[[0, 0], [height, width]]}
          className="store-map"
          whenCreated={(map) => {
            mapRef.current = map;
            setMapReady(true);
          }}
        >
          {/* Auto-scroll component */}
          {currentCoords && (
            <SetViewOnClick coords={currentCoords} zoom={currentZoom} />
          )}

          {/* Boundary rectangle */}
          <Rectangle
            bounds={[[0, 0], [300, 500]]}
            pathOptions={{ 
              color: '#000', 
              weight: 5, 
              fillOpacity: 0,
              dashArray: "5, 5"
            }}
          />

          {/* Render grid */}
          {renderGrid()}

          {/* Render entrance */}
          {mapData?.specialAreas?.entrance && (
            <Rectangle
              bounds={[
                [mapData.specialAreas.entrance.position[1], mapData.specialAreas.entrance.position[0]],
                [
                  mapData.specialAreas.entrance.position[1] + mapData.specialAreas.entrance.size[1],
                  mapData.specialAreas.entrance.position[0] + mapData.specialAreas.entrance.size[0]
                ]
              ]}
              pathOptions={{
                fillColor: '#4CAF50',
                color: '#2E7D32',
                fillOpacity: 0.7,
              }}
            >
              <Tooltip permanent>Entrance</Tooltip>
            </Rectangle>
          )}

          {/* Render checkout counters */}
          {mapData?.specialAreas?.checkout && (
            <Polygon
              positions={mapData.specialAreas.checkout.coordinates.map(([x, y]) => [y, x])}
              pathOptions={{
                fillColor: mapData.specialAreas.checkout.color || '#FFA500',
                color: '#000',
                weight: 2,
                fillOpacity: 0.8,
              }}
            >
              <Tooltip permanent>Checkout Counters</Tooltip>
            </Polygon>
          )}

          {/* Render categories */}
          {mapData?.categories?.map((cat, index) => {
            if (!cat.coordinates || cat.coordinates.length === 0) return null;
            
            const color = cat.color || '#c2dfff';
            const isHighlighted = productList.some(p => p.category === cat.name);
            const icon = cat.meta?.icon || 'üì¶';

            return (
              <Polygon
                key={`cat-${index}`}
                positions={cat.coordinates.map(([x, y]) => [y, x])}
                pathOptions={{
                  fillColor: color,
                  color: isHighlighted ? '#000' : '#333',
                  weight: isHighlighted ? 2 : 1,
                  fillOpacity: isHighlighted ? 0.9 : 0.7,
                }}
              >
                <Tooltip 
                  direction="center" 
                  permanent 
                  opacity={1}
                  className={`category-tooltip ${isHighlighted ? 'highlighted' : ''}`}
                >
                  <div className="tooltip-content" style={{ backgroundColor: color }}>
                    <span className="category-icon">{icon}</span> {cat.name}
                  </div>
                </Tooltip>
              </Polygon>
            );
          })}

          {/* Render navigation path */}
          {path.length > 1 && (
            <>
              <Polyline
                positions={path}
                pathOptions={{ 
                  color: '#4285F4', 
                  weight: 4,
                  dashArray: '8, 8',
                  lineCap: 'round'
                }}
              />
              <Marker 
                position={path[0]} 
                icon={L.divIcon({
                  className: 'start-marker',
                  html: '<div>START</div>',
                  iconSize: [60, 30],
                  iconAnchor: [30, 15],
                })}
              />
              <Marker 
                position={path[path.length - 1]} 
                icon={L.divIcon({
                  className: 'end-marker',
                  html: '<div>END</div>',
                  iconSize: [60, 30],
                  iconAnchor: [30, 15],
                })}
              />
              <Marker 
                position={path[currentIndex]} 
                icon={L.divIcon({
                  className: 'current-marker',
                  html: `<div class="pulse">${currentIndex + 1}</div>`,
                  iconSize: [30, 30],
                  iconAnchor: [15, 15],
                })}
              />
            </>
          )}
        </MapContainer>

        <div className="product-drawer">
          <h3 className="product-drawer-title">
            <span className="cart-icon">üõí</span> 
            Your Shopping Path
            <span className="item-count">{productList.length} items</span>
          </h3>
          <div className="product-list">
            {productList.map((p, i) => {
              // Find category to get color and icon
              const category = mapData?.categories?.find(c => c.name === p.category);
              const color = category?.color || '#c2dfff';
              const icon = category?.meta?.icon || 'üì¶';
              
              return (
                <div 
                  key={i} 
                  className={`product-card ${i === currentIndex ? 'active' : ''}`}
                  onClick={() => setCurrentIndex(i)}
                  style={{ 
                    borderLeft: `4px solid ${color}`,
                    backgroundColor: i === currentIndex ? '#f0f7ff' : 'white'
                  }}
                >
                  <div className="product-icon">{icon}</div>
                  <div className="product-info">
                    <strong className="product-name">{p.name}</strong>
                    <div className="product-meta">
                      <span className="product-category" style={{ color }}>
                        {p.category}
                      </span>
                    </div>
                  </div>
                  <div className="product-index">{i + 1}</div>
                </div>
              );
            })}
          </div>
        </div>
      </div>
    </div>
  );
};

export default IndoorMapComponent;